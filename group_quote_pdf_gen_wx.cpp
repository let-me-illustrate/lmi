// Generate group premium quote PDF file.
//
// Copyright (C) 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 Gregory W. Chicares.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
//
// https://savannah.nongnu.org/projects/lmi
// email: <gchicares@sbcglobal.net>
// snail: Chicares, 186 Belle Woods Drive, Glastonbury CT 06033, USA

#include "pchfile_wx.hpp"

#include "group_quote_pdf_gen.hpp"

#include "alert.hpp"
#include "assert_lmi.hpp"
#include "calendar_date.hpp"            // jdn_t()
#include "force_linking.hpp"
#include "html.hpp"
#include "icon_monger.hpp"              // load_image()
#include "ledger.hpp"
#include "ledger_invariant.hpp"
#include "ledger_text_formats.hpp"      // ledger_format()
#include "ledger_variant.hpp"
#include "math_functions.hpp"           // outward_quotient()
#include "mc_enum_types_aux.hpp"        // is_subject_to_ill_reg()
#include "miscellany.hpp"               // split_into_lines()
#include "oecumenic_enumerations.hpp"
#include "pdf_writer_wx.hpp"
#include "ssize_lmi.hpp"
#include "version.hpp"
#include "wx_table_generator.hpp"
#include "wx_utility.hpp"               // ConvertDateToWx()
#include "wx_workarounds.hpp"           // wxDCTextColorChanger

#include <wx/datetime.h>
#include <wx/image.h>

#include <cstring>                      // strstr()
#include <limits>
#include <memory>                       // unique_ptr
#include <stdexcept>
#include <utility>                      // pair
#include <vector>

LMI_FORCE_LINKING_IN_SITU(group_quote_pdf_generator_wx)

namespace
{

/// Transform 's' -> '<br><br>s', but return empty string unchanged.

html::text brbr(std::string const& s)
{
    using namespace html;

    return s.empty()
        ? text()
        : tag::br + tag::br + text::from(s)
        ;
}

/// Transform 's' -> '<br><br><b>s</b>', but return empty string unchanged.

html::text brbrb(std::string const& s)
{
    using namespace html;

    return s.empty()
        ? text()
        : tag::br + tag::br + tag::b(text::from(s))
        ;
}

/// Generate HTML representation of a field name and value in an HTML table.
///
/// The HTML fragment generated by this function contains two <td> tags with
/// the given contents.

html::text name_value_as_html_table_data
    (std::string const& name
    ,std::string const& value
    )
{
    using namespace html;

    auto const nbsp2 = text::nbsp() + text::nbsp();

    return
        tag::td[attr::nowrap][attr::align("right")]
            (tag::b
                (text::from(name))
                (text::from(value.empty() ? "" : ":"))
                (nbsp2)
            )
        +
        tag::td
            (text::from(value))
            (nbsp2 + nbsp2)
        ;
}

/// Simple description of a custom field, consisting of a non-empty name and a
/// possibly empty string value.
///
/// Objects of this class have value semantics.

struct extra_summary_field
{
    std::string name;
    std::string value;
};

/// Function parsing a multiline string of the form "name: value" as an array
/// of extra summary fields.

std::vector<extra_summary_field> parse_extra_report_fields(std::string const& s)
{
    std::vector<std::string> const lines = split_into_lines(s);

    std::vector<extra_summary_field> fields;
    fields.reserve(lines.size());

    for(auto const& i : lines)
        {
        // Ignore the empty or blank lines, they could be added for readability
        // reasons and this also deals with the problem of split_into_lines()
        // returning a vector of a single empty line even if the source string
        // is entirely empty.
        if(i.find_first_not_of(' ') == std::string::npos)
            {
            continue;
            }

        extra_summary_field field;

        std::string::size_type const pos_colon = i.find(':');

        // Notice that substr() call is correct even if there is no colon in
        // this line, i.e. pos_colon == npos.
        field.name = i.substr(0, pos_colon);

        if(pos_colon != std::string::npos)
            {
            // Skip any spaces after the colon as this is what would be
            // normally expected by the user.
            std::string::size_type const
                pos_value = i.find_first_not_of(' ', pos_colon + 1);

            if(pos_value != std::string::npos)
                {
                field.value = i.substr(pos_value);
                }
            }
        // else: If there is no colon or nothing but space after it, just leave
        // the value empty, this is unusual, but not considered to be an error.

        fields.push_back(field);
        }

    return fields;
}

enum enum_group_quote_columns
    {e_col_number
    ,e_col_name
    ,e_col_age
    ,e_col_dob
    ,e_col_basic_face_amount
    ,e_col_basic_premium
    ,e_col_supplemental_face_amount
    ,e_col_additional_premium
    ,e_col_total_face_amount
    ,e_col_total_premium
    ,e_col_max
    };

enum_group_quote_columns const e_first_totalled_column = e_col_basic_face_amount;

struct column_definition
{
    char const*              header_;
    char const*              widest_text_; // PDF !! Empty string means variable width.
    mutable oenum_visibility visibility_ {oe_shown};
};

// Headers of premium columns include dynamically-determined payment
// mode, so they're actually format strings.
// PDF !! This ought not to be a global variable.

column_definition const column_definitions[] =
    {{"Part#"                          ,            "99999"   } // e_col_number
    ,{"Participant"                    ,                 ""   } // e_col_name
    ,{"Issue Age"                      ,              "999"   } // e_col_age
    ,{"Date of Birth"                  ,       "9999-99-99"   } // e_col_dob
    ,{"Basic\nFace Amount"             , "$999,999,999,999"   } // e_col_basic_face_amount
    ,{"Basic\n%s\nPremium"             ,   "$9,999,999,999.00"} // e_col_basic_premium
    ,{"Supplemental\nFace Amount"      , "$999,999,999,999"   } // e_col_supplemental_face_amount
    ,{"Additional\n%s\nPremium"        ,   "$9,999,999,999.00"} // e_col_additional_premium
    ,{"Total\nFace Amount"             , "$999,999,999,999"   } // e_col_total_face_amount
    ,{"Total\n%s\nPremium"             ,   "$9,999,999,999.00"} // e_col_total_premium
    };

static_assert(lmi::ssize(column_definitions) == e_col_max);

class group_quote_pdf_generator_wx
    :public group_quote_pdf_generator
{
  public:
    // do_create() requires a public ctor; that's harmless because
    // this is inside an unnamed namespace.
    group_quote_pdf_generator_wx() = default;

    static std::unique_ptr<group_quote_pdf_generator> do_create()
        {
        return std::make_unique<group_quote_pdf_generator_wx>();
        }

    void add_ledger(Ledger const& ledger) override;
    void save(std::string const& output_filename) override;

  private:
    // This value is arbitrary and can be changed to conform to subjective
    // preferences.
    static int const vert_skip = 12;

    // Compute the number of pages needed by the table rows in the output given
    // the space remaining on the first page, the heights of the header, one
    // table row and the footer and the last row position.
    // Remaining space contains the space on the first page on input and is
    // updated with the space remaining on the last page on output.
    int compute_pages_for_table_rows
        (pdf_writer_wx& pdf_writer
        ,int          & remaining_space
        ,int            header_height
        ,int            row_height
        ,int            last_row_y
        );

    void output_page_number_and_version
        (pdf_writer_wx& pdf_writer
        ,int            total_pages
        ,int            current_page
        );
    void output_image_header
        (pdf_writer_wx& pdf_writer
        ,int          & pos_y
        );
    void output_document_header
        (pdf_writer_wx& pdf_writer
        ,int          & pos_y
        );
    void output_aggregate_values
        (pdf_writer_wx     & pdf_writer
        ,wx_table_generator& table_gen
        ,int&                pos_y
        );
    void output_footer
        (pdf_writer_wx                & pdf_writer
        ,int                          & pos_y
        ,oenum_render_or_only_measure   output_mode
        );

    class totals_data; // Fwd decl for fill_global_report_data() argument.
    struct global_report_data
        {
        // Extract header and footer fields from composite ledger and totals.
        void fill_global_report_data(Ledger const& ledger, totals_data const& totals);

        // Fixed fields that are always defined.
        std::string company_;
        std::string prepared_by_;
        std::string product_;
        std::string short_product_;
        std::string premium_mode_;
        std::string contract_state_;
        std::string effective_date_;
        html::text  footer_html_;

        // Dynamically-determined fields.
        std::string elected_riders_;
        std::string elected_riders_footnote_;
        std::string plan_type_;
        std::string plan_type_footnote_;

        // Optional supplementary fields.
        std::vector<extra_summary_field> extra_fields_;
        };
    global_report_data report_data_;

    struct row_data
        {
        std::vector<std::string> output_values {e_col_max};
        };
    std::vector<row_data> rows_;

    class totals_data
    {
      public:
        totals_data()
            {
            for(int i = e_first_totalled_column; i < e_col_max; ++i)
                {
                value(i) = 0.0;
                }
            }

        void total(int col, double d)
            {
            value(col) = d;
            }

        double total(int col) const
            {
            return const_cast<totals_data*>(this)->value(col);
            }

      private:
        double& value(int col) { return values_[col - e_first_totalled_column]; }

        double values_[e_col_max - e_first_totalled_column];
    };
    totals_data totals_;

    int  row_num_              {0};
    bool individual_selection_ {}; // Initialized by add_ledger().
};

void assert_nonblank(std::string const& value, std::string const& name)
{
    if(std::string::npos == value.find_first_not_of(" \f\n\r\t\v"))
        {
        alarum() << name << " must not be blank." << LMI_FLUSH;
        }
}

/// Copy global report data from ledger.
///
/// Member data from class Input that are used here are checked for
/// consistency upstream by assert_okay_to_run_group_quote().
/// Therefore, any changes in the set of data used here should be
/// reflected there if possible.

void group_quote_pdf_generator_wx::global_report_data::fill_global_report_data
    (Ledger      const& ledger
    ,totals_data const& totals
    )
{
    LedgerInvariant const& invar = ledger.GetLedgerInvariant();

    bool has_suppl_specamt_ = 0.0 != totals.total(e_col_supplemental_face_amount);
    plan_type_ =
        (invar.GroupIndivSelection ? invar.GroupQuoteRubricVoluntary
        :has_suppl_specamt_        ? invar.GroupQuoteRubricFusion
        :                            invar.GroupQuoteRubricMandatory
        );
    plan_type_footnote_ =
        (invar.GroupIndivSelection ? invar.GroupQuoteFooterVoluntary
        :has_suppl_specamt_        ? invar.GroupQuoteFooterFusion
        :                            invar.GroupQuoteFooterMandatory
        );

    elected_riders_ += (invar.HasWP         ) ? invar.WaiverTerseName + ", ": "";
    elected_riders_ += (invar.HasADD        ) ? invar.ADDTerseName    + ", ": "";
    elected_riders_ += (invar.HasChildRider ) ? invar.ChildTerseName  + ", ": "";
    elected_riders_ += (invar.HasSpouseRider) ? invar.SpouseTerseName + ", ": "";
    if(!elected_riders_.empty())
        {
        // Remove superfluous trailing comma and blank.
        elected_riders_.pop_back();
        elected_riders_.pop_back();
        // Replace last comma with a conjunction.
        std::string::size_type pos = elected_riders_.rfind(",");
        if(std::string::npos != pos)
            {
            elected_riders_.replace(pos, 1, " and");
            }
        }

    if(!elected_riders_.empty())
        {
        elected_riders_footnote_ =
              "This composite includes "
            + elected_riders_
            + "."
            ;
        if(invar.HasSpouseRider)
            {
            std::pair<int,oenum_format_style> const f1(0, oe_format_normal);
            double const number_of_lives = invar.GetInforceLives().at(0);
            LMI_ASSERT(0.0 < number_of_lives);
            elected_riders_footnote_ +=
                  " The spouse coverage amount is $"
                + ledger_format(invar.SpouseRiderAmount / number_of_lives, f1)
                + "."
                ;
            }
        }

    company_          = invar.CorpName;
    prepared_by_      = invar.ProducerName;
    product_          = invar.PolicyMktgName;
    short_product_    = invar.GroupQuoteShortProductName;
    premium_mode_     = invar.InitErMode;
    contract_state_   = invar.StateOfJurisdiction;
    jdn_t eff_date    = jdn_t(static_cast<int>(invar.EffDateJdn));
    effective_date_   = ConvertDateToWx(eff_date).FormatDate().ToStdString();
    // Deliberately begin the footer with <br> tags, to separate it
    // from the logo right above it.
    footer_html_ =
          brbr (invar.GroupQuoteIsNotAnOffer)
        + brbr (invar.GroupQuoteRidersFooter)
        + brbr (elected_riders_footnote_)
        + brbr (plan_type_footnote_)
        + brbr (invar.GroupQuotePolicyFormId)
        + brbr (invar.GroupQuoteStateVariations)
        + brbr (invar.MarketingNameFootnote)
        + brbrb(invar.GroupQuoteProspectus)
        + brbr (invar.GroupQuoteUnderwriter)
        + brbr (invar.GroupQuoteBrokerDealer)
        ;

    assert_nonblank(company_         , "Sponsor");
    assert_nonblank(prepared_by_     , "Agent");
    assert_nonblank(product_         , "Product name");
    assert_nonblank(short_product_   , "Product ID");
    assert_nonblank(premium_mode_    , "Mode");
    assert_nonblank(contract_state_  , "State");
    assert_nonblank(effective_date_  , "Effective date");
    // elected_riders_ may be blank.
    assert_nonblank(plan_type_       , "Plan type");

    assert_nonblank(invar.GroupQuoteIsNotAnOffer   , "First footnote");
    assert_nonblank(invar.GroupQuoteRidersFooter   , "Second footnote");
    // The third footnote (elected riders) may be blank.
    assert_nonblank(plan_type_footnote_            , "Fourth footnote");
    assert_nonblank(invar.GroupQuotePolicyFormId   , "Fifth footnote");
    assert_nonblank(invar.GroupQuoteStateVariations, "Sixth footnote");
    assert_nonblank(invar.MarketingNameFootnote    , "Seventh footnote");
    // Somewhat casually, assume that a contract is variable iff it's
    // not subject to the NAIC illustration reg.
    if(!is_subject_to_ill_reg(ledger.ledger_type()))
        {
        assert_nonblank(invar.GroupQuoteProspectus  , "Eighth footnote");
        assert_nonblank(invar.GroupQuoteUnderwriter , "Ninth footnote");
        assert_nonblank(invar.GroupQuoteBrokerDealer, "Tenth footnote");
        }

    extra_fields_     = parse_extra_report_fields(invar.Comments);
}

void group_quote_pdf_generator_wx::add_ledger(Ledger const& ledger)
{
    if(0 == ledger.GetCurrFull().LapseYear)
        {
        alarum() << "Lapsed during first year." << LMI_FLUSH;
        }

    LedgerInvariant const& invar = ledger.GetLedgerInvariant();

    // Function assert_okay_to_run_group_quote() takes arguments only
    // of class Input, so it can't check ledger variables such as
    //   AllowGroupQuote
    //   NoLongerIssued
    //   GroupIndivSelection
    // which are checked only here.
    if
        (  !static_cast<bool>(invar.AllowGroupQuote)
        ||  static_cast<bool>(invar.NoLongerIssued)
        )
        {
        alarum() << "Group quotes not allowed on this plan." << LMI_FLUSH;
        }

    // Needed only because some legacy products unfortunately combined
    // mandatory (unismoke) and voluntary (smoker-distinct) rates in
    // the same plancode, when they should have used distinct subplans
    // because they serve different market segments.
    if(0 == row_num_)
        {
        individual_selection_ = invar.GroupIndivSelection;
        }
    else
        {
        // static_cast to avoid an msvc warning:
        if(static_cast<bool>(invar.GroupIndivSelection) != individual_selection_)
            {
            alarum()
                << "Group quotes cannot mix mandatory and voluntary on the same plan."
                << LMI_FLUSH
                ;
            }
        }

    int const year = 0;

    std::pair<int,oenum_format_style> const f1(0, oe_format_normal);
    std::pair<int,oenum_format_style> const f2(2, oe_format_normal);

    bool const is_composite = ledger.is_composite();

    row_data rd;
    for(int i = 0; i < e_col_max; ++i)
        {
        // The cast is only used to ensure that if any new elements are added
        // to the enum, the compiler would warn about their values not being
        // present in this switch.
        switch(static_cast<enum_group_quote_columns>(i))
            {
            case e_col_number:
                {
                // Row numbers shown to human beings should be 1-based.
                rd.output_values[i] = wxString::Format("%d", row_num_ + 1).ToStdString();
                }
                break;
            case e_col_name:
                {
                rd.output_values[i] = invar.Insured1;
                }
                break;
            case e_col_age:
                {
                rd.output_values[i] = wxString::Format("%.0f", invar.Age).ToStdString();
                }
                break;
            case e_col_dob:
                {
                rd.output_values[i] = ConvertDateToWx
                    (jdn_t(static_cast<int>(invar.DateOfBirthJdn))
                    ).FormatDate().ToStdString(wxConvUTF8);
                }
                break;
            case e_col_basic_face_amount:
                {
                double const z = invar.SpecAmt.at(year) / 100.0;
                rd.output_values[i] = '$' + ledger_format(z, f1);
                if(is_composite)
                    {
                    totals_.total(i, z);
                    }
                }
                break;
            case e_col_basic_premium:
                {
                double const z = invar.ErModalMinimumPremium.at(year) / 100.0;
                rd.output_values[i] = '$' + ledger_format(z, f2);
                if(is_composite)
                    {
                    totals_.total(i, z);
                    }
                }
                break;
            case e_col_supplemental_face_amount:
                {
                double const z = invar.TermSpecAmt.at(year) / 100.0;
                rd.output_values[i] = '$' + ledger_format(z, f1);
                if(is_composite)
                    {
                    totals_.total(i, z);
                    }
                }
                break;
            case e_col_additional_premium:
                {
                double const z = invar.EeModalMinimumPremium.at(year) / 100.0;
                rd.output_values[i] = '$' + ledger_format(z, f2);
                if(is_composite)
                    {
                    totals_.total(i, z);
                    }
                }
                break;
            case e_col_total_face_amount:
                {
                double const z = (invar.SpecAmt.at(year) + invar.TermSpecAmt.at(year)) / 100.0;
                rd.output_values[i] = '$' + ledger_format(z, f1);
                if(is_composite)
                    {
                    totals_.total(i, z);
                    }
                }
                break;
            case e_col_total_premium:
                {
                double const z = invar.ModalMinimumPremium.at(year) / 100.0;
                rd.output_values[i] = '$' + ledger_format(z, f2);
                if(is_composite)
                    {
                    totals_.total(i, z);
                    }
                }
                break;
            case e_col_max:
                {
                alarum() << "Unreachable." << LMI_FLUSH;
                }
                break;
            }
        }

    // The composite ledger arrives last. It is used only for global
    // data (which have already been asserted, upstream, not to vary
    // by cell) and for totals. It is neither shown in the main table
    // nor counted as a row. Only at this point, after all the other
    // ledgers have been seen, can all-zero columns (and corresponding
    // total columns) be suppressed.
    if(is_composite)
        {
        report_data_.fill_global_report_data(ledger, totals_);
        }
    else
        {
        rows_.push_back(rd);
        ++row_num_;
        }
}

void group_quote_pdf_generator_wx::save(std::string const& output_filename)
{
    pdf_writer_wx pdf_writer
        (output_filename
        ,wxLANDSCAPE
        ,{6, 7, 8, 9, 11, 13, 16} // Standard HTML font sizes for 8pt base.
        );

    int pos_y = 0;

    output_image_header(pdf_writer, pos_y);
    pos_y += 2 * vert_skip;

    output_document_header(pdf_writer, pos_y);
    pos_y += 2 * vert_skip;

    // Some of the table columns don't need to be shown if all the values in
    // them are zeroes.
    bool const has_suppl_amount = totals_.total(e_col_supplemental_face_amount) != 0.0;
    bool const has_addl_premium = totals_.total(e_col_additional_premium      ) != 0.0;

    std::vector<column_parameters> vc;
    std::vector<int> indices;
    for(int i = 0; i < e_col_max; ++i)
        {
        column_definition const& cd = column_definitions[i];
        std::string header;
        oenum_h_align alignment = oe_center;
        // PDF !! This doesn't fit into the switch logic below.
        if(e_col_name == i) {alignment = oe_left;}
        oenum_visibility visibility = oe_shown;
        oenum_elasticity elasticity = oe_inelastic;
        // PDF !! This doesn't fit into the switch logic below.
        if(e_col_name == i) {elasticity = oe_elastic;}

        // The cast is only used to ensure that if any new elements are added
        // to the enum, the compiler would warn about their values not being
        // present in this switch.
        switch(static_cast<enum_group_quote_columns>(i))
            {
            case e_col_supplemental_face_amount:
            case e_col_total_face_amount:
                if(!has_suppl_amount) {visibility = oe_hidden;}
                // Fall through
            case e_col_number:
            case e_col_name:
            case e_col_age:
            case e_col_dob:
            case e_col_basic_face_amount:
                // Labels of these columns are simple literals.
                header = cd.header_;
                break;
            case e_col_additional_premium:
            case e_col_total_premium:
                if(!has_addl_premium) {visibility = oe_hidden;}
                // Fall through
            case e_col_basic_premium:
                {
                // Labels of these columns are format strings as they need to
                // be constructed dynamically.
                LMI_ASSERT(std::strstr(cd.header_, "%s"));
                header = wxString::Format
                    (cd.header_, report_data_.premium_mode_
                    ).ToStdString();
                }
                break;
            case e_col_max:
                {
                alarum() << "Unreachable." << LMI_FLUSH;
                }
                break;
            }

        indices.push_back(lmi::ssize(vc));
        cd.visibility_ = visibility;
        if(oe_shown == visibility)
            {
            vc.push_back({header, cd.widest_text_, alignment, elasticity});
            }
        }
    // Add a one-past-the-end index equal to the last value, because
    // some member functions of class wx_table_generator expect it.
    indices.push_back(lmi::ssize(vc));

    wx_table_generator table_gen
        (group_quote_style_tag{}
        ,vc
        ,indices
        ,pdf_writer.dc()
        ,pdf_writer.get_horz_margin()
        ,pdf_writer.get_page_width()
        );

    output_aggregate_values(pdf_writer, table_gen, pos_y);

    int const y_before_header = pos_y;
    table_gen.output_headers(pos_y);
    int const header_height = pos_y - y_before_header;

    int y_after_footer = pos_y;
    output_footer(pdf_writer, y_after_footer, oe_only_measure);
    int const footer_height = y_after_footer - pos_y;

    int const last_row_y = pdf_writer.get_page_bottom();
    int remaining_space = last_row_y - pos_y;

    int total_pages = compute_pages_for_table_rows
        (pdf_writer
        ,remaining_space
        ,header_height
        ,table_gen.row_height()
        ,last_row_y
        );

    // Check if the footer fits into the same page or if it needs a new one (we
    // never want to have a page break in the footer).
    bool const footer_on_its_own_page
        = remaining_space < (footer_height + 2 * vert_skip);
    if(footer_on_its_own_page)
        {
        ++total_pages;
        }

    int current_page = 1;

    for(auto const& i : rows_)
        {
        LMI_ASSERT(lmi::ssize(i.output_values) == lmi::ssize(column_definitions));
        std::vector<std::string> visible_values;
        for(int j = 0; j < e_col_max; ++j)
            {
            if(oe_shown == column_definitions[j].visibility_)
                {
                visible_values.push_back(i.output_values[j]);
                }
            }

        // If there is no space left for this row on the current page, start a
        // new one.
        if(last_row_y <= pos_y + table_gen.row_height())
            {
            output_page_number_and_version(pdf_writer, total_pages, current_page);

            ++current_page;
            pdf_writer.dc().StartPage();

            pos_y = pdf_writer.get_vert_margin();
            table_gen.output_headers(pos_y);
            }

        table_gen.output_row(pos_y, visible_values);
        }

    if(footer_on_its_own_page)
        {
        output_page_number_and_version(pdf_writer, total_pages, current_page);

        ++current_page;
        pdf_writer.dc().StartPage();

        pos_y = pdf_writer.get_vert_margin();
        }
    else
        {
        pos_y += 2 * vert_skip;
        }

    output_footer(pdf_writer, pos_y, oe_render);

    LMI_ASSERT(current_page == total_pages);
    output_page_number_and_version(pdf_writer, total_pages, current_page);

    pdf_writer.save();
}

int group_quote_pdf_generator_wx::compute_pages_for_table_rows
    (pdf_writer_wx& pdf_writer
    ,int          & remaining_space
    ,int            header_height
    ,int            row_height
    ,int            last_row_y
    )
{
    int total_pages = 1;

    int const max_rows_on_first_page = remaining_space / row_height;
    int remaining_rows = static_cast<int>(rows_.size());
    if(max_rows_on_first_page < remaining_rows)
        {
        // All rows don't fit on the first page, so add enough pages for the
        // rest of them.
        remaining_rows -= max_rows_on_first_page;

        int const first_row_y = pdf_writer.get_vert_margin() + header_height;
        int const page_area_y = last_row_y - first_row_y;
        int const rows_per_page = page_area_y / row_height;
        total_pages += outward_quotient(remaining_rows, rows_per_page);
        remaining_space = page_area_y;
        remaining_rows %= rows_per_page;
        if(!remaining_rows)
            {
            // If no rows remain, it actually means that the last page has the
            // maximum amount of rows as we don't have an extra page with 0
            // rows in this case.
            remaining_rows = rows_per_page;
            }
        }

    remaining_space -= remaining_rows * row_height;

    return total_pages;
}

void group_quote_pdf_generator_wx::output_page_number_and_version
    (pdf_writer_wx& pdf_writer
    ,int            total_pages
    ,int            current_page
    )
{
    wxRect const footer_area
        (pdf_writer.get_horz_margin()
        ,pdf_writer.get_page_bottom()
        ,pdf_writer.get_page_width()
        ,pdf_writer.get_vert_margin()
        );

    auto& pdf_dc = pdf_writer.dc();

    pdf_dc.DrawLabel
        (wxString::Format("System version: %s", LMI_VERSION)
        ,footer_area
        ,wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL
        );

    pdf_dc.DrawLabel
        (wxString::Format("Page %d of %d", current_page, total_pages)
        ,footer_area
        ,wxALIGN_RIGHT | wxALIGN_CENTER_VERTICAL
        );
}

void group_quote_pdf_generator_wx::output_image_header
    (pdf_writer_wx& pdf_writer
    ,int          & pos_y
    )
{
    wxImage banner_image(load_image("group_quote_banner.png"));
    if(!banner_image.IsOk())
        {
        return;
        }

    // Set the scale to fit the image to the document width.
    double const image_width = banner_image.GetWidth();
    double const scale = image_width / pdf_writer.get_total_width();
    int const pos_top = pos_y;
    pdf_writer.output_image(banner_image, "banner", scale, 0, pos_y);

    auto& pdf_dc = pdf_writer.dc();

    wxDCFontChanger set_bigger_font(pdf_dc, pdf_dc.GetFont().Scaled(1.5));
    wxDCTextColorChanger set_white_text(pdf_dc, *wxWHITE);
    // PDF !! This should not be necessary--see:
    //   https://lists.nongnu.org/archive/html/lmi/2020-08/msg00003.html
    wxDCTextBgModeChanger set_transparent_background(pdf_dc, wxPENSTYLE_TRANSPARENT);

    // Don't use html::text::from() here: instead, call
    // wxString::FromUTF8() directly, e.g., to preserve literal '&'.
    wxString const image_text
        (wxString::FromUTF8(report_data_.short_product_.c_str())
         + "\nPremium & Benefit Summary"
        );

    pdf_dc.DrawLabel
        (image_text
        ,wxRect
            (wxPoint(pdf_writer.get_horz_margin(), (pos_top + pos_y) / 2)
            ,pdf_dc.GetMultiLineTextExtent(image_text)
            )
        ,wxALIGN_CENTER_HORIZONTAL
        );
}

void group_quote_pdf_generator_wx::output_document_header
    (pdf_writer_wx& pdf_writer
    ,int          & pos_y
    )
{
    using namespace html;

    auto title_html =
        tag::table[attr::width("100%")]
            (tag::tr
                (tag::td[attr::align("center")]
                    (tag::i
                        (tag::font[attr::size("+1")]
                            (text::from(report_data_.company_)
                            )
                        )
                    )
                )
            )
            (tag::tr
                (tag::td[attr::align("center")]
                    (tag::i
                        (text::from
                            ("Prepared Date: "
                            +wxDateTime::Today().FormatDate().ToStdString()
                            )
                        )
                    )
                )
            )
            (tag::tr
                (tag::td[attr::align("center")]
                    (tag::i
                        (text::from("Prepared By: " + report_data_.prepared_by_)
                        )
                    )
                )
            );

    pdf_writer.output_html
        (pdf_writer.get_horz_margin()
        ,pos_y
        ,pdf_writer.get_page_width() / 2
        ,title_html
        );

    // Build the summary table with all the mandatory fields, starting by
    // building the (partly) dynamic fields rows part.

    // Add fixed fields first, then any additional ones,
    // in left-to-right then top-to-bottom order.
    std::vector<extra_summary_field> fields;

    fields.push_back({"Product",                report_data_.product_                           });
    fields.push_back({"Effective Date",         report_data_.effective_date_                    });

    // Append the space to ensure the field name is followed by a colon even if
    // the value is empty.
    fields.push_back({"Riders",                 report_data_.elected_riders_ + " "              });
    fields.push_back({"Contract State",         report_data_.contract_state_                    });

    fields.push_back({"Number of Participants", wxString::Format("%d", row_num_).ToStdString()  });
    fields.push_back({"Premium Mode",           report_data_.premium_mode_                      });

    fields.push_back({"Plan Type",              report_data_.plan_type_                         });

    std::vector<extra_summary_field> const& f = report_data_.extra_fields_;
    fields.insert(fields.end(), f.begin(), f.end());

    text fields_html;
    for(int i = 0; i < lmi::ssize(fields); i += 2)
        {
        auto row_html = name_value_as_html_table_data
            (fields[i].name, fields[i].value
            )
            ;

        if(i + 1 < lmi::ssize(fields))
            {
            row_html += name_value_as_html_table_data
                    (fields[i + 1].name, fields[i + 1].value
                    )
                    ;
            }

        fields_html += tag::tr(row_html);
        }

    // Finally close the summary table.
    auto const summary_html =
        tag::table[attr::width("100%")]
                  [attr::cellspacing("0")]
                  [attr::cellpadding("0")]
            (tag::tr
                (tag::td[attr::align("center")][attr::colspan("4")]
                    (tag::font[attr::size("+1")]
                        (text::from("Plan Details Summary"))
                    )
                )
            )
            (fields_html
            )
            ;

    int const summary_height = pdf_writer.output_html
        (pdf_writer.get_horz_margin() + pdf_writer.get_page_width() / 2
        ,pos_y
        ,pdf_writer.get_page_width() / 2
        ,summary_html
        );

    // wxHTML tables don't support "frame" attribute, so draw the border around
    // the table manually.
    auto& pdf_dc = pdf_writer.dc();
    pdf_dc.SetBrush(*wxTRANSPARENT_BRUSH);
    pdf_dc.DrawRectangle
        (pdf_writer.get_horz_margin() + pdf_writer.get_page_width() / 2
        ,pos_y
        ,pdf_writer.get_page_width() / 2
        ,summary_height
        );

    pos_y += summary_height;
}

void group_quote_pdf_generator_wx::output_aggregate_values
    (pdf_writer_wx     & pdf_writer
    ,wx_table_generator& table_gen
    ,int               & pos_y
    )
{
    table_gen.output_horz_separator(e_first_totalled_column, e_col_max, pos_y);
    table_gen.output_vert_separator(e_first_totalled_column, pos_y);
    table_gen.output_vert_separator(e_col_max, pos_y);

    pos_y += table_gen.row_height();
    int const y_next = pos_y + table_gen.row_height();

    table_gen.output_vert_separator(e_col_number, pos_y);
    table_gen.output_vert_separator(e_col_number, y_next);

    auto& pdf_dc = pdf_writer.dc();

    // Render "Census" in bold.
    // PDF !! Instead, consider using output_highlighted_cell(), with extra
    // arguments to specify font, brush, and pen.
    wxDCFontChanger set_bold_font(pdf_dc, pdf_dc.GetFont().Bold());
    pdf_dc.DrawLabel
        ("Census"
        ,table_gen.external_text_rect(e_col_name, pos_y)
        ,wxALIGN_LEFT
        );

    // And the aggregates in bold italic: notice that there is no need to create
    // another wxDCFontChanger here, the original font will be restored by the
    // one just above anyhow.
    pdf_dc.SetFont(pdf_dc.GetFont().Italic());

    LMI_ASSERT(0 < e_first_totalled_column);
    pdf_dc.DrawLabel
        ("Totals:"
        ,table_gen.external_text_rect(e_first_totalled_column - 1, pos_y)
        ,wxALIGN_RIGHT
        );

    pdf_dc.DrawLabel
        ("Average Cost per $1000:"
        ,table_gen.external_text_rect(e_first_totalled_column - 1, y_next)
        ,wxALIGN_RIGHT
        );

    for(int i = e_first_totalled_column; i < e_col_max; ++i)
        {
        if(oe_shown != column_definitions[i].visibility_)
            {
            continue;
            }

        int const decimals =
            ((e_col_basic_face_amount           == i) ? 0
            :(e_col_basic_premium               == i) ? 2
            :(e_col_supplemental_face_amount    == i) ? 0
            :(e_col_additional_premium          == i) ? 2
            :(e_col_total_face_amount           == i) ? 0
            :(e_col_total_premium               == i) ? 2
            :throw std::logic_error("Invalid column type.")
            );
        std::pair<int,oenum_format_style> const f(decimals, oe_format_normal);

        table_gen.output_highlighted_cell
            (i
            ,pos_y
            ,'$' + ledger_format(totals_.total(i), f)
            );

        // Average cost per $1000 is presented only for the "basic"
        // and "total" premium columns. It obviously cannot be defined
        // for face-amount columns. Less obviously, it doesn't make
        // sense to define it for "additional" premium. Due to the
        // unusual design of the main product this is intended to
        // support, "additional" premium might include:
        //   - a required dumpin, whose natural divisor is the "basic"
        //     face amount; and
        //   - charges for "supplemental" face amount, for which that
        //     amount (if present) is the natural divisor; and
        //   - charges for spouse and child riders, whose natural
        //     divisors are their respective benefit amounts.
        // It would in theory be possible to write special-case logic
        // for the first two cases, but not for the third, and
        // not for each of the eight possible combinations of these
        // three cases.

        std::string average_text;

        // The cast is only used to ensure that if any new elements are added
        // to the enum, the compiler would warn about their values not being
        // present in this switch.
        switch(static_cast<enum_group_quote_columns>(i))
            {
            case e_col_basic_premium:
                {
                double const dividend = totals_.total(e_col_basic_premium);
                double const divisor  = totals_.total(e_col_basic_face_amount);
                LMI_ASSERT(0.0 != divisor);
                double const average = 1000.0 * dividend / divisor;
                average_text = '$' + ledger_format(average, f);
                }
                break;
            case e_col_total_premium:
                {
                double const dividend = totals_.total(e_col_total_premium);
                double const divisor  = totals_.total(e_col_total_face_amount);
                LMI_ASSERT(0.0 != divisor);
                double const average = 1000.0 * dividend / divisor;
                average_text = '$' + ledger_format(average, f);
                }
                break;
            case e_col_basic_face_amount:
            case e_col_supplemental_face_amount:
            case e_col_additional_premium:
            case e_col_total_face_amount:
                {
                // Do nothing: leave 'average_text' empty.
                }
                break;
            case e_col_number: // fall through--should be unreachable
            case e_col_name:   // fall through--should be unreachable
            case e_col_age:    // fall through--should be unreachable
            case e_col_dob:    // fall through--should be unreachable
            case e_col_max:    // fall through--should be unreachable
            default:
                {
                alarum() << "Case " << i << " not found." << LMI_FLUSH;
                }
            }

        // For columns that do not have averages, writing an empty
        // string ensures that the background is homogeneous.
        table_gen.output_highlighted_cell(i, y_next, average_text);
        }

    table_gen.output_vert_separator(e_col_max, pos_y);
    table_gen.output_horz_separator(e_col_number, e_col_max, pos_y);

    table_gen.output_vert_separator(e_col_max, y_next);
    table_gen.output_horz_separator(e_first_totalled_column, e_col_max, y_next);

    pos_y = y_next + table_gen.row_height();
}

void group_quote_pdf_generator_wx::output_footer
    (pdf_writer_wx                & pdf_writer
    ,int                          & pos_y
    ,oenum_render_or_only_measure   output_mode
    )
{
    wxImage logo_image(load_image("company_logo.png"));
    if(logo_image.IsOk())
        {
        // Arbitrarily scale down the logo by a factor of 2 to avoid making it
        // too big.
        pdf_writer.output_image
            (logo_image
            ,"company_logo"
            ,2.0
            ,pdf_writer.get_horz_margin()
            ,pos_y
            ,output_mode
            );

        pos_y += vert_skip;
        }

    auto footer_html = html::tag::p(report_data_.footer_html_);

    pos_y += pdf_writer.output_html
        (pdf_writer.get_horz_margin()
        ,pos_y
        ,pdf_writer.get_page_width()
        ,footer_html
        ,output_mode
        );
}

bool volatile ensure_setup = group_quote_pdf_generator_wx::set_creator
    (group_quote_pdf_generator_wx::do_create
    );

} // Unnamed namespace.
